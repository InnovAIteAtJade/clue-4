<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MAGNETIC FIELD</title>
<style>
    body {
        margin: 0;
        background: #111;
        overflow: hidden;
        color: #888;
        font-family: sans-serif;
        user-select: none;
    }

    canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
        cursor: text;
    }
</style>
</head>
<body>

<canvas id="world"></canvas>

<script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    let textPoints = [];
    let isMagnetized = false;

    // "PRESS AND HOLD [SPACE] TO SYNCHRONIZE DATA" (ASCII Codes)
    const _c = [80,82,69,83,83,32,65,78,68,32,72,79,76,68,32,91,83,80,65,67,69,93,32,84,79,32,83,89,78,67,72,82,79,78,73,90,69,32,68,65,84,65];
    const _h = String.fromCharCode(..._c);

    // Custom Selection State
    let sel = { x: 0, y: 0, w: 0, h: 0, active: false };

    const _l = [
        "RmluYWxseSwgc2VhbCB5b3VyIGpvdXJuZXku",
        "VGhlIGZpbmFsIHN0ZXAgY29uZmlybXMgYWxsIHRoYXQgeW91J3ZlIGRvbmUu",
        "U29sdmUgdGhlIHJpZGRsZSBhbmQgdmVyaWZ5IHlvdXIgYW5zd2VyIG9uIHRoZSBwb3J0YWwu",
        "R29vZCBsdWNrIQ=="
    ];

    function init() {
        resize();
        
        const tCan = document.createElement('canvas');
        const tCtx = tCan.getContext('2d');
        tCan.width = width;
        tCan.height = height;
        
        tCtx.textAlign = "center";
        tCtx.textBaseline = "middle";
        tCtx.fillStyle = "red";
        
        const fontSize = Math.min(width / 40, 30); 
        tCtx.font = `bold ${fontSize}px Arial`;

        const lineHeight = fontSize * 1.5;
        const totalHeight = _l.length * lineHeight;
        const startY = (height / 2) - (totalHeight / 2) + (lineHeight / 2);

        _l.forEach((line, index) => {
            const decoded = atob(line);
            tCtx.fillText(decoded, width / 2, startY + (index * lineHeight));
        });
        
        const idata = tCtx.getImageData(0, 0, width, height).data;
        
        const step = 2;
        for(let y=0; y<height; y+=step) {
            for(let x=0; x<width; x+=step) {
                const alpha = idata[(y * width + x) * 4 + 3];
                if(alpha > 128) {
                    textPoints.push({x: x, y: y});
                }
            }
        }

        const count = Math.max(textPoints.length, 5000); 
        
        for(let i=0; i<count; i++) {
            const targetIndex = i < textPoints.length ? i : null;
            const target = targetIndex !== null ? textPoints[targetIndex] : null;
            
            particles.push({
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                target: target,
                color: target ? '#00ffff' : '#222' 
            });
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    
    window.addEventListener('resize', () => {
        particles = [];
        textPoints = [];
        init();
    });

    window.addEventListener('keydown', (e) => { if(e.code === 'Space') isMagnetized = true; });
    window.addEventListener('keyup', (e) => { if(e.code === 'Space') isMagnetized = false; });
    
    let mx = -1000, my = -1000;
    
    // Mouse Events for Custom Selection
    window.addEventListener('mousedown', (e) => {
        sel.x = e.clientX;
        sel.y = e.clientY;
        sel.w = 0;
        sel.h = 0;
        sel.active = true;
    });

    window.addEventListener('mousemove', (e) => { 
        mx = e.clientX; 
        my = e.clientY; 
        if(sel.active) {
            sel.w = mx - sel.x;
            sel.h = my - sel.y;
        }
    });

    window.addEventListener('mouseup', () => {
        sel.active = false;
        // Optional: clear selection on release or keep it? 
        // Standard behavior is keep until click. For simplicity, we clear on click.
        sel.w = 0; sel.h = 0;
    });

    function loop() {
        ctx.fillStyle = "rgba(17, 17, 17, 0.3)"; 
        ctx.fillRect(0, 0, width, height);

        // 1. Draw Hint (Invisible Layer)
        ctx.save();
        ctx.font = "14px monospace";
        ctx.textAlign = "center";
        ctx.fillStyle = "#161616"; // Almost background color
        ctx.fillText(_h, width/2, height - 30);
        ctx.restore();

        // 2. Draw Selection & Reveal
        if (sel.w !== 0 || sel.h !== 0) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 255, 65, 0.3)"; // Selection Highlight
            ctx.fillRect(sel.x, sel.y, sel.w, sel.h);
            
            // Clip to selection area
            ctx.beginPath();
            ctx.rect(sel.x, sel.y, sel.w, sel.h);
            ctx.clip();
            
            // Draw Hint Again (Visible Color)
            ctx.fillStyle = "#ffffff"; 
            ctx.font = "14px monospace";
            ctx.textAlign = "center";
            ctx.fillText(_h, width/2, height - 30);
            ctx.restore();
        }

        particles.forEach(p => {
            if (isMagnetized && p.target) {
                const dx = p.target.x - p.x;
                const dy = p.target.y - p.y;
                p.vx += dx * 0.08; 
                p.vy += dy * 0.08;
                p.vx *= 0.85;
                p.vy *= 0.85;
            } else {
                p.vx += (Math.random() - 0.5) * 0.2;
                p.vy += (Math.random() - 0.5) * 0.2;
                const max = 3;
                if(Math.abs(p.vx) > max) p.vx *= 0.9;
                if(Math.abs(p.vy) > max) p.vy *= 0.9;
            }

            const dx = p.x - mx;
            const dy = p.y - my;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 100) {
                const force = (100 - dist) / 100;
                p.vx += (dx / dist) * force * 5;
                p.vy += (dy / dist) * force * 5;
            }

            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > width) p.vx *= -1;
            if (p.y < 0 || p.y > height) p.vy *= -1;

            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 1.5, 1.5); 
        });

        requestAnimationFrame(loop);
    }

    init();
    loop();

</script>
</body>
</html>
